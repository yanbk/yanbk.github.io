{"meta":{"title":"我的博客","subtitle":null,"description":"专注 WEB 开发的技术博客","author":"yanbk","url":"http://yanbk.github.io"},"pages":[{"title":"关于我","date":"2019-02-19T07:51:22.000Z","updated":"2019-02-21T06:27:06.353Z","comments":true,"path":"about/index.html","permalink":"http://yanbk.github.io/about/index.html","excerpt":"","text":"yanbk"},{"title":"test","date":"2019-02-21T06:49:53.000Z","updated":"2019-02-21T06:49:53.134Z","comments":true,"path":"test/index.html","permalink":"http://yanbk.github.io/test/index.html","excerpt":"","text":""}],"posts":[{"title":"微信小程序unionid获取","slug":"wxunionid","date":"2019-07-12T08:34:28.000Z","updated":"2019-07-12T08:55:58.862Z","comments":true,"path":"2019/07/12/wxunionid/","link":"","permalink":"http://yanbk.github.io/2019/07/12/wxunionid/","excerpt":"","text":"####问题背景 通过观察数据，发现有一部分用户是无法获取到UnionId的也就是接口返回的参数中不包含UnionId参数 看了微信文档的解释，只要小程序在开放平台绑定，就一定会分配UnionId 网上也有用户遇到这样的情况，没有解决 ####问题影响 使用微信小程序成功授权以后，下次在公众号中授权或在App中使用微信授权，无法识别是同一个微信用户，可能会出现一个微信用户绑定不同App用户的情况。 ####UnionID机制 1如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。 12同一个微信开放平台下的相同主体的App、公众号、小程序，如果用户已经关注公众号，或者曾经登录过App或公众号，则用户打开小程序时，开发者可以直接通过wx.login获取到该用户UnionID，无须用户再次授权。 ####注意： 后边这句话的描述 用户关注过公众号，或者曾经登录过App或公众号，则用户打开小程序时，开发者可以直接通过wx.login获取到该用户UnionID 即：如果用户没有关注过公众号，或者没有登陆过App，通过wx.login是无法获取到该用户UnionID，只能通过wx.getUserInfo来获取UnionId 经验证，系统不存在UnionId的小程序用户都是没有关注公众号或未在App中使用微信授权的用户 ####解决方案 获取小程序UnionId应该以wx.getUserInfo的UnionId为主 wx.getUserInfo需要用户授权，产品方面，需要考虑用户拒绝授权的处理流程 ###微信未授权关注公众号或者登录APP如何获取unionid 1、在utils中创建RdWXBizDataCrypt.js 123456789101112131415161718192021222324252627282930var Crypto = require(&apos;./cryptojs.js&apos;).Crypto;function RdWXBizDataCrypt(appId, sessionKey) &#123; this.appId = appId this.sessionKey = sessionKey&#125;RdWXBizDataCrypt.prototype.decryptData = function (encryptedData, iv) &#123; // base64 decode ：使用 CryptoJS 中 Crypto.util.base64ToBytes()进行 base64解码 var encryptedData = Crypto.util.base64ToBytes(encryptedData) var key = Crypto.util.base64ToBytes(this.sessionKey); var iv = Crypto.util.base64ToBytes(iv); // 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充 var mode = new Crypto.mode.CBC(Crypto.pad.pkcs7); try &#123; // 解密 var bytes = Crypto.AES.decrypt(encryptedData, key, &#123; asBpytes: true, iv: iv, mode: mode &#125;); var decryptResult = JSON.parse(bytes); &#125; catch (err) &#123; console.log(err) &#125; if (decryptResult.watermark.appid !== this.appId) &#123; console.log(err) &#125; return decryptResult&#125;module.exports = RdWXBizDataCrypt 2、在utils中创建lib文件，把lib中的文件加载进去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var WXBizDataCrypt = require(&apos;../../utils/cryptojs/RdWXBizDataCrypt.js&apos;);//获取应用实例var app = getApp()var appId = &quot;你的小程序id&quot;;var secret = &apos;你的小程序secret &apos;;Page(&#123; data: &#123; motto: &apos;Hello World&apos;, userInfo: &#123;&#125;, hasUserInfo: false, canIUse: wx.canIUse(&apos;button.open-type.getUserInfo&apos;), openId:&apos;&apos;,//用户唯一标识 date:&quot;1999-12-22&quot;, unionId:&apos;&apos;, encryptedData:&apos;&apos; &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: &apos;../logs/logs&apos; &#125;) &#125;,onLoad: function () &#123; var that =this; wx.login(&#123; success: res =&gt; &#123; //发起网络请求 wx.request(&#123;//这是我自己的java服务器的接口，将login（）获得的code发送的服务器换取session_key url: &apos;https://api.yuedou.live/admin/getopenid, data: &#123; js_code: res.code, &#125;, header: &#123; &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;, method: &apos;POST&apos;, success: function (res) &#123; console.log(res.data.session_key) //拿到session_key实例化WXBizDataCrypt（）这个函数在下面解密用 var pc = new WXBizDataCrypt(appId, res.data.session_key) wx.getUserInfo(&#123; success: function (res) &#123; //拿到getUserInfo（）取得的res.encryptedData, res.iv，调用decryptData（）解密 var data = pc.decryptData(res.encryptedData, res.iv) // data.unionId就是咱们要的东西了 app.globalData.unionid = data.unionId console.log(&apos;解密后 unionid: &apos;, app.globalData.unionid) &#125;, fail: function (res) &#123; console.log(res) &#125; &#125;) &#125;, fail: function (res) &#123; &#125;, complete: function (res) &#123; &#125; &#125;); &#125; &#125;)&#125;","categories":[],"tags":[]},{"title":"centos","slug":"centos","date":"2019-06-12T01:33:50.000Z","updated":"2019-06-12T01:55:07.932Z","comments":true,"path":"2019/06/12/centos/","link":"","permalink":"http://yanbk.github.io/2019/06/12/centos/","excerpt":"","text":"###下载安装centOS ####服务端1.先从yum安装git1yum -y install git 2.在需要的位置创建一个裸仓库（最后以.git结尾）1234lsmkdir gitcd gitgit init --bare test.git 3.创建一个git用户并赋予密码12useradd gitpasswd git 4.赋予git权限1chown -R git:git test.git 5.查看centOS的ip1ip addr 如果没有找到ip，需要修改配置文件1vi /etc/sysconfig/network-scripts/ifcfg-xxx //xxx每个机器都不一样 修改其中的ONBOOT=yes重启服务1service network restart 再操作5就能获取ip地址 ####本地1.本地初始化一个git仓库1git init 2.然后提交本地代码至本地仓库12git add .git commit -m &quot;提交的描述&quot; 3.最后将本地仓库提交到远程仓库1git push -u git@*.*.*.*:/root/git/test.git master","categories":[{"name":"front","slug":"front","permalink":"http://yanbk.github.io/categories/front/"}],"tags":[{"name":"centOS","slug":"centOS","permalink":"http://yanbk.github.io/tags/centOS/"}]},{"title":"vue组件异步加载","slug":"component-resolve","date":"2019-02-21T11:34:52.000Z","updated":"2019-02-22T02:09:06.526Z","comments":true,"path":"2019/02/21/component-resolve/","link":"","permalink":"http://yanbk.github.io/2019/02/21/component-resolve/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334import Vue from &apos;vue&apos;import VueRouter from &apos;vue-router&apos;// &quot;@&quot;相当于&quot;..&quot;import Detail from &apos;../pages/goodsDetail&apos;import Msg from &apos;../components/message.vue&apos;// 使用路由Vue.use(VueRouter)export default new VueRouter(&#123; mode: &apos;history&apos;, routes: [ &#123; // 进行路由配置,规定&apos;/&apos;引入到home组件 path: &apos;/&apos;, component: resolve =&gt; require([&apos;../pages/home.vue&apos;], resolve), meta: &#123; title: &apos;home&apos; &#125; &#125;, &#123; path: &apos;/msg&apos;, component: Msg &#125;, &#123; path: &apos;/detail&apos;, component: Detail, children: [ &#123; path: &apos;msg&apos;, component: Msg &#125; ] &#125; ]&#125;) 1component: resolve =&gt; require([&apos;../pages/home.vue&apos;], resolve), 如果用import引入的话，当项目打包时路由里的所有component都会打包在一个js中，造成进入首页时，需要加载的内容过多，时间相对比较长。当你用require这种方式引入的时候，会将你的component分别打包成不同的js，加载的时候也是按需加载，只用访问这个路由网址时才会加载这个js。你可以打包的时候看看目录结构就明白了。","categories":[],"tags":[{"name":"componet","slug":"componet","permalink":"http://yanbk.github.io/tags/componet/"}]},{"title":"什么是MVVM，MVC和MVVM的区别，MVVM框架VUE实现原理","slug":"mvvm","date":"2019-02-21T07:32:08.000Z","updated":"2019-02-21T08:00:52.744Z","comments":true,"path":"2019/02/21/mvvm/","link":"","permalink":"http://yanbk.github.io/2019/02/21/mvvm/","excerpt":"","text":"Mvvm定义MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。MVVM流程图如下： MVC的定义：MVC是Model-View- Controller的简写。即模型-视图-控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。‘MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。MVC和MVVM的区别并不是VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的重用。由于mvc出现的时间比较早，前端并不那么成熟，很多业务逻辑也是在后端实现，所以前端并没有真正意义上的MVC模式。而我们今天再次提起MVC，是因为大前端的来到，出现了MVVM模式的框架，我们需要了解一下MVVM这种设计模式是如何一步步演变过来的。 为什么会有MVVM框架？在过去的10年中，我们已经把很多传统的服务端代码放到了浏览器中，这样就产生了成千上万行的javascript代码，它们连接了各式各样的HTML 和CSS文件，但缺乏正规的组织形式，这也就是为什么越来越多的开发者使用javascript框架。比如：angular、react、vue。浏览器的兼容性问题已经不再是前端的阻碍。前端的项目越来越大，项目的可维护性和扩展性、安全性等成了主要问题。当年为了解决浏览器兼容性问题，出现了很多类库，其中最典型的就是jquery。但是这类库没有实现对业务逻辑的分成，所以维护性和扩展性极差。综上两方面原因，才有了MVVM模式一类框架的出现。比如vue,通过数据的双向绑定，极大了提高了开发效率。 MVVM框架:VUE的介绍Vue就是基于MVVM模式实现的一套框架，在vue中：Model:指的是js中的数据，如对象，数组等等。View:指的是页面视图viewModel:指的是vue实例化对象为什么说VUE是一个渐进式的javascript框架, 渐进式是什么意思？1.如果你已经有一个现成的服务端应用，你可以将vue 作为该应用的一部分嵌入其中，带来更加丰富的交互体验;2.如果你希望将更多业务逻辑放到前端来实现，那么VUE的核心库及其生态系统也可以满足你的各式需求（core+vuex+vue-route）。和其它前端框架一样，VUE允许你将一个网页分割成可复用的组件，每个组件都包含属于自己的HTML、CSS、JAVASCRIPT以用来渲染网页中相应的地方。3.如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成为各自的组件和文件，vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单（vue init webpack my-project）。我们可以使用VUE的单文件组件，它包含了各自的HTML、JAVASCRIPT以及带作用域的CSS或SCSS。以上这三个例子，是一步步递进的，也就是说对VUE的使用可大可小，它都会有相应的方式来整合到你的项目中。所以说它是一个渐进式的框架。VUE最独特的特性：响应式系统VUE是响应式的（reactive），也就是说当我们的数据变更时，VUE会帮你更新所有网页中用到它的地方。关于这个响应式原理，官方已经讲得很清楚，不懂的同学，可以https://cn.vuejs.org/v2/guide/reactivity.html 查看。 主流框架实现双向绑定（响应式）的做法： 脏值检查：angularangular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。 观察者-订阅者（数据劫持）：vueObserver 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。执行流程如下：从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。","categories":[],"tags":[{"name":"mvvm","slug":"mvvm","permalink":"http://yanbk.github.io/tags/mvvm/"}]},{"title":"apktool","slug":"apktool","date":"2018-06-21T03:07:08.000Z","updated":"2018-06-21T05:53:16.407Z","comments":true,"path":"2018/06/21/apktool/","link":"","permalink":"http://yanbk.github.io/2018/06/21/apktool/","excerpt":"","text":"使用工具1231. apktool (资源文件获取)2. dex2jar (源码文件获取)3. jd-gui （源码查看） 工具介绍 apktool download 作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看 dex2jar download 作用：将apk反编译成java源码（classes.dex转化成jar文件） jd-gui download 作用：查看APK中classes.dex转化成出的jar文件，即源码文件 工具使用 apktool和apktool.jar移到/usr/local/bin文件夹下 1apktool -v 检测是否成功 执行命令apktool d example.apk 会生成一个文件 这个文件夹下可以看到apk中的资源文件，如图片，xml文件等等，如果你只需要获取图片等资源文件那么到这里就可以了，若要进一步获取java代码的话就需要用到dex2jar和jd-gui工具了 要获取java代码的话就要进行回编译（apktoo可以进行反编译和回编译），主要就是获取classex.dex文件。 执行命令 apktool b example 得倒反编译生成的文件 此时将获得的classes.dex文件拷贝到dex2jar解压的文件夹下面： 然后执行dex2jar.sh classes.dex 得到classes-dex2jar.jar 将此文件拖入jd-ui软件中即可查看源码","categories":[{"name":"tools","slug":"tools","permalink":"http://yanbk.github.io/categories/tools/"}],"tags":[{"name":"apktool","slug":"apktool","permalink":"http://yanbk.github.io/tags/apktool/"}]},{"title":"node xlsx","slug":"node-xlsx","date":"2018-06-21T02:47:06.000Z","updated":"2018-06-21T02:56:09.137Z","comments":true,"path":"2018/06/21/node-xlsx/","link":"","permalink":"http://yanbk.github.io/2018/06/21/node-xlsx/","excerpt":"","text":"第一步引入包1npm install xlsx --save 第二部使用12345678910var fs = require(&quot;fs&quot;);var xlsx = require(&quot;xlsx&quot;);//workbook 对象，指的是整份 Excel 文档。var workbook = xlsx.readFile(&quot;./test.xlsx&quot;)const sheetNames = workbook.SheetNames; // 返回 [&apos;sheet1&apos;, &apos;sheet2&apos;]// 根据表名获取对应某张表const worksheet = workbook.Sheets[sheetNames[0]];var data =xlsx.utils.sheet_to_csv(worksheet);console.log(sheetNames,data.split(&quot;\\n&quot;)) 详情介绍","categories":[{"name":"front","slug":"front","permalink":"http://yanbk.github.io/categories/front/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yanbk.github.io/tags/node/"}]},{"title":"react-native-web","slug":"react-native-web","date":"2018-06-05T09:30:57.000Z","updated":"2018-06-05T09:48:18.766Z","comments":true,"path":"2018/06/05/react-native-web/","link":"","permalink":"http://yanbk.github.io/2018/06/05/react-native-web/","excerpt":"","text":"##第一步：创建react-native工程1react-native init myDemo ##第二步：接入react，react-dom123cd myDemonpm install react-dom --savenpm install babel-loader webpack webpack-dev-server babel-preset-env babel-preset-react react-transform-hmr --save ##第三步：创建web文件 ###1、在app目录下创建web文件夹，在web文件夹下创建webpack.config.js文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; devServer: &#123; inline: false, contentBase: path.join(__dirname, &apos;/dist&apos;) &#125;, entry: [ path.join(__dirname, &apos;../index.web.js&apos;) // 之前创建的 index.web.js 文件路径 ], // entry: &apos;../index.web.js&apos;, output: &#123; /* 打包后的内容输出到config.js文件目录下的 dist 目录下（没有就创建一个） */ path: path.join(__dirname, &apos;/dist&apos;), filename: &apos;bundle.js&apos;, // 打包后的文件名 publicPath: &apos;/&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader:&apos;babel-loader?cacheDirectory=true&apos;, query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125;, &#123; test: /\\.(gif|jpe?g|png|svg)$/, loader: &apos;url-loader&apos;, query: &#123; name: &apos;[name].[hash:16].[ext]&apos; &#125; &#125; ] &#125;, plugins: [ new webpack.DefinePlugin(&#123; &apos;process.env.NODE_ENV&apos;: JSON.stringify(process.env.NODE_ENV || &apos;development&apos;) &#125;), /* webpack插件，用来打包本地的html模板到编译后的文件中 */ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &apos;/index.html&apos;), &#125;), ], resolve: &#123; alias: &#123; &apos;react-native&apos;: &apos;react-native-web&apos; &#125; &#125;&#125;; ###2、在web目录下创建.babelrc文件：12345678910111213141516&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;], &quot;env&quot;: &#123; &quot;development&quot;: &#123; &quot;plugins&quot;: [ [&quot;react-transform&quot;, &#123; &quot;transforms&quot;: [&#123; &quot;transform&quot;: &quot;react-transform-hmr&quot;, &quot;imports&quot;: [&quot;react&quot;], &quot;locals&quot;: [&quot;module&quot;] &#125;] &#125;] ] &#125; &#125;&#125; ###3、在app目录下创建index.web.js文件 12345import React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import App from &apos;./src/App&apos;;render(&lt;App /&gt;, document.getElementById(&apos;root&apos;)); ###4、在web目录下创建dist文件夹，在dist文件夹下创建index.html：12345678910&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&apos;root&apos;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;bundle.web.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ###5、在package.json里面配置脚本：123456&quot;scripts&quot;: &#123; ... &quot;webStart&quot;: &quot;webpack --config ./web/webpack.config.js&quot;, &quot;webServer&quot;: &quot;webpack-dev-server --open --config ./web/webpack.config.js --port 8082 --host 172.16.11.80&quot;, &quot;webBuild&quot;: &quot;NODE_ENV=production webpack --config ./webpack.production.config.js --progress&quot; &#125;, ###6、在web目录下创建dist文件夹下创建index.html：12345678910&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&apos;root&apos;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ##第四步：运行Web项目12执行npm run webStart执行npm run webServer 1234567891011121314151617安装各种依赖&quot;babel-loader&quot;: &quot;^7.1.4&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;dom&quot;: &quot;0.0.3&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;react&quot;: &quot;16.3.1&quot;, &quot;react-art&quot;: &quot;^16.4.0&quot;, &quot;react-dom&quot;: &quot;^16.4.0&quot;, &quot;react-native&quot;: &quot;0.55.4&quot;, &quot;react-native-web&quot;: &quot;^0.8.0&quot;, &quot;react-navigation&quot;: &quot;^2.1.0&quot;, &quot;react-transform-hmr&quot;: &quot;^1.0.4&quot;, &quot;webpack&quot;: &quot;^4.10.2&quot;, &quot;webpack-cli&quot;: &quot;^3.0.2&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.4&quot;","categories":[{"name":"front","slug":"front","permalink":"http://yanbk.github.io/categories/front/"}],"tags":[{"name":"react-native-web","slug":"react-native-web","permalink":"http://yanbk.github.io/tags/react-native-web/"}]},{"title":"ie67","slug":"ie67","date":"2018-03-23T06:38:05.000Z","updated":"2018-03-23T06:39:08.291Z","comments":true,"path":"2018/03/23/ie67/","link":"","permalink":"http://yanbk.github.io/2018/03/23/ie67/","excerpt":"","text":"123456789101112131415161718IE6/IE7下对display:inline-block的支持性不好。1、inline元素的display属性设置为inline-block时，所有的浏览器都支持；2、block元素的display属性设置为inline-block时，IE6/IE7浏览器是不支持的； 对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行，允许空格。（准确地说，应用此特性的元素现为内联对象，周围元素保持在同一行，但可以设置宽度和高度等块元素的属性） IE中对内联元素使用display:inline-block，IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表征。从上面的这个分析，也不难理解为什么IE下，对块元素设置display:inline-block属性无法实现inline-block的效果。这时块元素仅仅是被display:inline-block触发了layout，而它本身就是行布局，所以触发后，块元素依然还是行布局，而不会如Opera中块元素呈递为内联对象。 IE6下块元素如何实现display:inline-block的效果？有两种方法：1、 先使用display:inline-block属性触发块元素，然后再定义display:inline，让块元素呈递为内联对象（两个display 要先后放在两个CSS声明中才有效果，这是IE的一个经典bug，如果先定义了display:inline-block，然后再将display设回 inline或block，layout不会消失）。代码如下（...为省略的其他属性内容）： div &#123;display:inline-block;...&#125; div &#123;display:inline;&#125;2、直接让块元素设置为内联对象呈递（设置属性display:inline），然后触发块元素的layout（如：zoom:1 或float属性等）。代码如下：div &#123; display:inline-block; _zoom:1;_display:inline;&#125; /*推荐*/div &#123; display:inline-block; _zoom:1;*display:inline;&#125; /*推荐:IE67*/","categories":[{"name":"front","slug":"front","permalink":"http://yanbk.github.io/categories/front/"}],"tags":[{"name":"ie67","slug":"ie67","permalink":"http://yanbk.github.io/tags/ie67/"}]},{"title":"macapache","slug":"macapache","date":"2018-03-23T02:14:04.000Z","updated":"2018-03-23T02:36:02.221Z","comments":true,"path":"2018/03/23/macapache/","link":"","permalink":"http://yanbk.github.io/2018/03/23/macapache/","excerpt":"","text":"打开终端，开启Apache:12345//开启apache: sudo apachectl start//重启apache: sudo apachectl restart//关闭apache: sudo apachectl stop 点击Finder,然后Command+Shift+G,前往Apache服务器的文件路径(/Library/WebServer/Documents)在步骤1中只输入一个http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容。此时如果我在浏览器的网址框输入的是http://127.0.0.1/PoweredByMacOSX.gif, 浏览器就便会显示PoweredByMacOSX.gif图片,如果没有正常显示，提示说没有权限时，单击该文件，然后Command+I在末尾设置权限即可。 在Mac上搭建了PHP服务器以后，默认的路径为/Library/WebServer/Documents下面，但这让人很不爽，我想修改到自己定义的路径下。经过好一番折腾，终于成功了。因为网上有很多搭建环境的教程，所以本文就不在赘述。 打开文件/private/etc/apache2/httpd.conf找到 1LoadModule userdir_module libexec/apache2/mod_userdir.so 将#去掉 在用户名下创建文件夹Sites 修改/private/etc/apache2/httpd.conf文件中的DocumentRoot为： 12DocumentRoot &quot;/Users/yanbk/Sites&quot;&lt;Directory &quot;/Users/yanbk/Sites&quot;&gt; 创建文件/private/etc/apache2/users/yanbk.conf 并在文件中输入以下代码 12345&lt;Directory &quot;/Users/tangjr/Sites/&quot;&gt; Options Indexes MultiViews AllowOverride All Require all granted # OSX 10.10 / Apache 2.4&lt;/Directory&gt; 找到/private/etc/apache2/httpd.conf文件中 1Options FollowSymLinks Multiviews 修改为 1Options FollowSymLinks Multiviews Indexes 重启apache服务器 1sudo apachectl restart","categories":[{"name":"tools","slug":"tools","permalink":"http://yanbk.github.io/categories/tools/"}],"tags":[{"name":"apache","slug":"apache","permalink":"http://yanbk.github.io/tags/apache/"}]},{"title":"audio自动播放","slug":"audioplay","date":"2018-03-23T01:07:49.000Z","updated":"2018-03-23T02:35:51.538Z","comments":true,"path":"2018/03/23/audioplay/","link":"","permalink":"http://yanbk.github.io/2018/03/23/audioplay/","excerpt":"","text":"一种解决h5页面背景音乐不能自动播放的方案 场景：微信、浏览器、App 普通解决方案：采用audio标签的autoplay属性 现象：1.大部分IOS系统和少部分Android微信不支持自动播放$解决方案：监听WeixinJSBridgeReady事件、DOMContentLoaded事件微信的JS API建立在微信壳浏览器的内置JS对象WeixinJSBridge上，WeixinJSBridge并不是WebView一打开就有了，客户端需要初始化这个对象，当这个对象准备好的时候，客户端会抛出事件”WeixinJSBridgeReady”。发现部分机型，监听DOMContentLoaded和load事件，在回调中也可以播放音乐；所以，为了保险起见，可以同时监听两个事件，以增强其适用性。代码如下： 123456789101112&lt;audio style=&quot;display:none; height: 0&quot; id=&quot;bg-music&quot; preload=&quot;auto&quot; src=&quot;../static/videos/bg-music.mp3&quot; loop=&quot;loop&quot;&gt;&lt;/audio&gt;document.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123; function audioAutoPlay() &#123; var audio = document.getElementById(&apos;bg-music&apos;); audio.play(); document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123; audio.play(); &#125;, false); &#125; audioAutoPlay();&#125;); 2.部分Android浏览器和所有IOS下Safari浏览器不支持自动播放 解决方案：通过手势事件播放音乐 (1) 监听body的touchstart事件，回调中播放音乐； 缺点：部分元素的touch事件可能会阻止冒泡，需要在对应的地方调起播放音乐函数 (2) 可以增加透明层，点击到透明层，播放音乐，关闭透明层； 缺点：第一次点击按钮元素可能不响应，造成用户体验上的伤害。部分App不支持webview音乐自动播放 解决方案：1.壳浏览器支持；2.通过手势事件播放音乐 123456789101112131415161718192021222324252627 function autoPlayMusic() &#123; // 自动播放音乐效果，解决浏览器或者APP自动播放问题 function musicInBrowserHandler() &#123; musicPlay(true); document.body.removeEventListener(&apos;touchstart&apos;, musicInBrowserHandler); &#125; document.body.addEventListener(&apos;touchstart&apos;, musicInBrowserHandler); // 自动播放音乐效果，解决微信自动播放问题 function musicInWeixinHandler() &#123; musicPlay(true); document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123; musicPlay(true); &#125;, false); document.removeEventListener(&apos;DOMContentLoaded&apos;, musicInWeixinHandler); &#125; document.addEventListener(&apos;DOMContentLoaded&apos;, musicInWeixinHandler);&#125;function musicPlay(isPlay) &#123; var media = document.querySelector(&apos;#bg-music&apos;); if (isPlay &amp;&amp; media.paused) &#123; media.play(); &#125; if (!isPlay &amp;&amp; !media.paused) &#123; media.pause(); &#125;&#125;","categories":[{"name":"front","slug":"front","permalink":"http://yanbk.github.io/categories/front/"}],"tags":[{"name":"autoplay,audio","slug":"autoplay-audio","permalink":"http://yanbk.github.io/tags/autoplay-audio/"}]},{"title":"Hexo 使用","slug":"hexo","date":"2018-03-21T09:03:41.000Z","updated":"2018-03-23T06:03:44.583Z","comments":false,"path":"2018/03/21/hexo/","link":"","permalink":"http://yanbk.github.io/2018/03/21/hexo/","excerpt":"","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提12nodejsgit 然后1234$ npm install -g hexo-cli$ hexo init test$ cd test$ npm install Hexo教程 Hexo 的基本命令1234567891011hexo clean #清除PUBLIC和编译文件hexo generate #编译网站目录hexo deploy #同步到GIT 或者CODINGnpm install &lt;plugin-name&gt; --save #安装npm update #升级npm uninstall &lt;plugin-name&gt; #卸载 一些常用命令 12345678910111213hexo new”postName” #新建文章 #存放在主目录的source下的POST目录下hexo new page”pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 基本配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Site #站点信息title: lmintlcx #标题subtitle: 做人不卖萌跟咸鱼有什么区别 #副标题description: lmintlcx lm lcx blog #描述author: lmintlcx #作者language: zh-Hans #语言timezone: Asia/Shanghai #时区# URL #链接格式url: http://joryhe.coding.me/ #网址root: / #根目录permalink: post/:title.html #文章的链接格式permalink_defaults:# Directory #目录source_dir: source #源文件public_dir: public #生成的网页文件tag_dir: tags #标签archive_dir: archives #归档category_dir: categories #分类code_dir: downloads/codei18n_dir: :lang #国际化skip_render:# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认模板titlecase: false #标题转换成大写external_link: true #新标签页里打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #语法高亮 enable: true line_number: false #显示行号 auto_detect: true tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Date / Time format #日期时间格式date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination #分页per_page: 20 #每页文章数, 设置成 0 禁用分页pagination_dir: page# Extensions #插件和主题## 插件: http://hexo.io/plugins/## 主题: http://hexo.io/themes/theme: next# Deployment #部署, joryhe是我的用户名, 同时发布GitHub deploy: type: git repo: github: github: git@github.com:joryhe/joryhe.github.io.git,master# Disqus #Disqus评论系统disqus_shortname: plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap 主题配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677menu: #菜单 home: / #首页 archives: /archives #归档 about: /about #关于 #commonweal: /404.html #公益404 #tags: /tags #标签 #categories: /categories #分类## 经典介绍配置# 小图标favicon: /favicon.ico# 默认关键词keywords: # 留空使用默认的, false 禁用, 也可以写指定的地址rss:# Icon fonts# default | linecons | fifty-shades | feathericon_font: default# 代码高亮主题 https://github.com/chriskempson/tomorrow-theme# normal | night | night eighties | night blue | night brighthighlight_theme: normal# MathJax Support #数学公式mathjax: true# Schemes #启用主题中的主题Mistscheme: Mist# 侧边栏# - post 只在文章页面显示# - always 所有页面显示# - hide 隐藏sidebar: always# 自动滚动到&quot;阅读更多&quot;标记的下面scroll_to_more: true# 自动给目录添加序号toc_list_number: true# 自动截取摘要auto_excerpt: enable: false length: 150# Lato 字体use_font_lato: true# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: ROOT## DO NOT EDIT THE FOLLOWING SETTINGS## UNLESS YOU KNOW WHAT YOU ARE DOING# 动画use_motion: true# Fancybox 看图插件fancybox: true# Static filesvendors: vendorscss: cssjs: jsimages: images# Theme versionversion: 0.4.5.1 添加小图标将 favicon.ico 文件放在 source 目录下, 修改主题配置文件 1favicon: /favicon.ico 菜单导航栏设置配置在主题配置文件下 1234567menu: home: / archives: /archives categories: /categories tags: /tags commonweal: /404.html about: /about 新增标签页使用命令hexp new page “tags” 并将页面类型设置为tags 1234title: tagsdate: 2016-04-19 22:37:08type: &quot;tags&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码 12345title: tagsdate: 2016-04-19 22:37:08type: &quot;tags&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到标签导航栏 12menu: tags: /tags 新增分类页使用命令hexp new page categories 并将页面类型设置为categories 1234title: categoriesdate: 2016-04-19 22:38:00type: &quot;categories&quot;--- 通常情况下你的标签页并不需要评论框，取消评论代码 12345title: categoriesdate: 2016-04-19 22:38:00type: &quot;categories&quot;comments: false--- 在主题配置文件下的菜单设置项memu下设置，设置完成在主页导航可以看到分类导航栏 12menu: categories: /categories 关于自己颜面abouthexo new page “about”新增about页面 编辑source/about/index.md: 添加菜单导航，在主题配置文件 12menu: about: /about 侧边栏社交链接1234567# Social linkssocial: GitHub: https://github.com/lmintlcx Twitter: https://twitter.com/lmintlcx Zhihu: http://www.zhihu.com/people/lmintlcx Douban: http://www.douban.com/people/lmintlcx #Weibo: http://weibo.com/lmlcx HEXO建站","categories":[{"name":"front","slug":"front","permalink":"http://yanbk.github.io/categories/front/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yanbk.github.io/tags/hexo/"}]},{"title":"主题配置指导","slug":"config","date":"2018-03-16T00:59:44.000Z","updated":"2018-03-23T02:36:19.889Z","comments":true,"path":"2018/03/16/config/","link":"","permalink":"http://yanbk.github.io/2018/03/16/config/","excerpt":"","text":"如果你在此之前使用的是 Hexo 2.x 版本，为了避免未知的错误，请备份好数据，或者建立新的博客目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166## menu -- 导航菜单显示&#123;[@page:名字,@url:地址,@icon:图标]&#125;menu:- page: home url: / icon: fa-home## favicon -- 网站图标位置&#123;@favicon&#125;favicon: /favicon.ico## rss --rss文件位置&#123;@rss&#125;rss: /atom.xml# 各个小工具的设置## widgets -- 6个左边小工具&#123;@widgets:[notification,category,archive,tagcloud,friends]&#125;widgets:- search- notification - social- category- archive- tagcloud- friends# 各个小工具的设置## 搜索jsonContent: searchLocal: true // 是否启用本地搜索 searchGoogle: true //是否启用谷歌搜索 posts: title: true text: true content: true categories: false tags: false## notification config --网站公告设置,支持 html 和 纯文本notification: |- &lt;p&gt;主题已经上线！欢迎下载或更新~ &lt;br/&gt; 主题下载：&lt;a href=\"https://github.com/shenliyang/hexo-theme-snippet\" title=\"fork me\" target=\"_blank\"&gt;Snippet主题&lt;/a&gt; &lt;br/&gt; &lt;hr/&gt;接受贡献，包括不限于提交问题与需求，修复代码。欢迎Pull Request&lt;br/&gt;支持主题：&lt;a href=\"https://github.com/shenliyang/hexo-theme-snippet/stargazers\"&gt;Star一下&lt;/a&gt;&lt;/p&gt;## 社交设置&#123;@name:社交工具名字，@icon:社交工具图标，@href:设置工具链接&#125; [参考图标](http://fontawesome.io/icons/)social: - name: Github icon: git href: //github.com/shenliyang ## 文章分类设置&#123;@cate_config:&#123;@show_count:是否显示数字，@show_current: 是否高亮当前category&#125;&#125;cate_config: show_count: true show_current: true## 文章归档设置&#123;@arch_config:/*参数参考：https://hexo.io/zh-cn/docs/helpers.html#list-archives*/&#125;arch_config: type: 'monthly' show_count: true order: -1## 友链设置&#123;@链接名称：链接地址&#123;@links:[,,,]&#125;&#125;links: - 主题作者: http://www.shenliyang.com # 主题自定义个性化配置## 网站宣传语&#123;@branding：网站宣传语(不设置显示本地图片)&#125;branding: 从未如此简单有趣## 设置banner背景图片banner: img:## 首页文章列表缩略图### 加载规则: 自定义文章缩略图(在Front-matter中添加的'img'字段) &gt; 文章内的图片 &gt; defaultImgs(随机获取) &gt; 无图模式列表 ## 自定义随机图片defaultImgs: - http://www.example.jpg //远程图片链接示例 - /img/default-1.jpg //本地图片链接示例### 文章摘要&#123;@摘要显示优先级：自定义摘要 &gt; 自动截取摘要 &#125;### 自定义摘要范围&#123;@&lt;!--more--&gt;:截取more之前的内容为摘要&#125;### 自动截取摘要&#123;@excerptLength:自动截取文章前多少个字为摘要，不配置默认：120字&#125;excerptLength: 120## 代码高亮配置&#123;@highlightTheme: 主题名称,(配置暂时不可用，后续开发中…)&#125;highlightTheme: default //TODO## 文章过期提醒功能 &#123;@warning:&#123;days:临界天数(默认300天,设置0关闭功能),text:提醒文字/*%d为过期总天数占位符*/&#125;&#125;warning: days: 300 text: '本文于%d天之前发表，文中内容可能已经过时。' ## 文章内声明&#123;@declaration: &#123;enable:是否开启,title:声明标题,tip:提示内容&#125;&#125;declaration: enable: true title: '转载声明' tip: |- 商业转载请联系作者获得授权,非商业转载请注明出处 © &lt;a href=\"\" target=\"_blank\"&gt;Snippet&lt;/a&gt;## 主题评论### gitmentgitment: enable: false owner: repo: client_id: client_secret: labels: perPage: maxCommentHeight: ### 来必力(默认选项)livere: enable: true livere_uid: ### 友言评论(服务不稳定，经常无法加载)uyan: enable: false uyan_id: ### Disqus评论(需要翻墙，或者搭建代理)disqus: enable: false shortname: snippet count: false ### 畅言评论(需要ICP备案)changyan: enable: false appid: conf:## 网站访问统计### 网盟CNZZ统计 参考网站: [网盟CNZZ](http://www.umeng.com/) cnzz_anaylytics: ### 百度统计 参考网站: [百度统计](https://tongji.baidu.com/)baidu_anaylytics: ### 百度文章推送 参考网站: [百度站长](http://zhanzhang.baidu.com/) baidu_push:### 谷歌统计 参考网站：[谷歌统计](https://www.google-analytics.com/)google_anaylytics: ### 腾讯分析 参考网站：[腾讯分析](http://ta.qq.com/)tencent_analytics: ## ICON配置 (不配则启用本地Font Icon)fontAwesome: //cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css## 网站主题配置since: 2017 //建站时间robot: 'all' //控制搜索引擎的抓取和索引编制行为，默认为allversion: 1.2.1 //当前主题版本号 修改新增文章Front-matter模板,修改scaffolds目录下的post.md模板12345678--- title: &#123;&#123; title &#125;&#125; // 标题date: &#123;&#123; date &#125;&#125; // 时间categories: // 分类tags: // 标签comments: false // 是否开启评论img: // 自定义缩略图--- 如果要使用本地站点搜索，必须安装插件hexo-generator-json-content来创建本地搜索json文件1npm i hexo-generator-json-content@2.2.0 -S","categories":[{"name":"front","slug":"front","permalink":"http://yanbk.github.io/categories/front/"}],"tags":[{"name":"config","slug":"config","permalink":"http://yanbk.github.io/tags/config/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-03-15T14:14:28.623Z","updated":"2018-03-16T06:38:32.925Z","comments":true,"path":"2018/03/15/hello-world/","link":"","permalink":"http://yanbk.github.io/2018/03/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(“echo $input | $markdown_script”); Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. This is an example inline link. This link has no title attribute. See my About page for details. This is an example reference-style link. unbelievablebelievable Use the printf() function. Use A backtick-delimited string in a code span: `foo` address@example.com http://example.com/","categories":[],"tags":[]}]}